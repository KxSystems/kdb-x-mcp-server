KDB SQL Query Guide

Write ANSI-compliant SQL for kdb+ tables.

Basic Syntax:
SELECT [DISTINCT] columns FROM table
[LEFT|RIGHT|INNER|CROSS] JOIN table2 ON condition
WHERE conditions
GROUP BY columns
HAVING conditions
ORDER BY columns [ASC|DESC]
LIMIT n

Supported Features:

SELECT Operations:
- DISTINCT - unique values only
- AS - column/table aliases
- * and qualified column selection

Aggregates: SUM, AVG, COUNT, MIN, MAX, FIRST, LAST, TOTAL
- Support DISTINCT: COUNT(DISTINCT col)

Joins: LEFT, RIGHT, INNER, CROSS
- Nested joins supported
- NATURAL, USING, LATERAL not implemented

Filtering:
- WHERE with =, <, >, BETWEEN, IN, EXISTS, IS NULL
- LIKE uses standard ANSI SQL % wildcards (NOT q-style *)
- Examples: WHERE Symbol LIKE 'BTC%', WHERE Symbol LIKE '%USD', WHERE Symbol LIKE '%USDT%'
- No underscore (_) single character wildcards supported
- Subqueries in comparisons and IN clauses

Grouping:
- GROUP BY with column names, ordinals, or expressions
- HAVING for aggregate filtering

Combining Queries: UNION [ALL], INTERSECT [ALL], EXCEPT [ALL]

Advanced:
- Common Table Expressions: WITH t AS (SELECT...) SELECT FROM t
- Scalar and correlated subqueries
- CASE expressions (simple and searched)
- NULLIF, COALESCE
- CAST function

Data Types:
- Numeric: INTEGER, SMALLINT, REAL, DOUBLE, FLOAT
- String: CHARACTER, VARCHAR with LENGTH, SUBSTRING, UPPER, LOWER, POSITION
- Date/Time: DATE, TIME, TIMESTAMP with CURRENT_DATE, LOCALTIME, LOCALTIMESTAMP

Key Differences from Standard SQL:
- LIKE uses standard ANSI SQL % wildcards
- No UPDATE, DELETE, constraints, transactions, or privileges
- Tables are in-memory (no persistence)
- User-defined functions via .s.fs and .s.F

Examples:

Basic query with aggregation:
SELECT vendor, COUNT(*) as trip_count, AVG(fare) as avg_fare
FROM trips
WHERE payment_type IN ('cash', 'credit')
GROUP BY vendor
HAVING COUNT(*) > 100
ORDER BY trip_count DESC
LIMIT 10;

Join with subquery:
SELECT t.*, cc.description
FROM trips t
LEFT JOIN cash_credit cc ON t.payment_type = cc.payment_type
WHERE t.fare > (SELECT AVG(fare) FROM trips);

CTE example:
WITH daily_stats AS (
  SELECT date, SUM(fare) as total_fare, COUNT(*) as trip_count
  FROM trips GROUP BY date
)
SELECT * FROM daily_stats WHERE total_fare > 1000;

Pattern matching:
SELECT DISTINCT Symbol FROM crypto WHERE Symbol LIKE '%USDT%';
SELECT * FROM crypto WHERE Symbol LIKE 'BTC%' OR Symbol LIKE '%USD';

Date queries:
SELECT * FROM crypto
WHERE Datetime >= '2025-04-22T00:00:00'
ORDER BY Datetime DESC
LIMIT 100;